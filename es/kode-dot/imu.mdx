---
title: "IMU"
description: "Conoce la posición de tu kode dot"
icon: "compass"
---

# Características

En el interior de tu kode dot tienes integrado un giroscópio de 3 ejes, un acelerómetro de 3 ejes y un magnetómetro de 3 ejes. Así, puedes conocer la posición relativa a si 
mismo y su posición absoluta respecto La Tierra.

El giroscópio y el acelerómetro están en un mismo integrado y tienen las siguientes características:

| Característica                        | Descripción                                                                                                              |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| Acelerómetro + giroscopio “always-on” | Consumo total de **0,55 mA** en modo de alto rendimiento para operación continua.                                        |
| Rangos de medida                      | Acelerómetro **±2/4/8/16 g**  •  Giroscopio **±125/250/500/1000/2000 dps**.                                              |
| FIFO inteligente                      | Búfer de datos de hasta **9 KB** con compresión y batching dinámico.                                                     |
| Motor de IA embebido                  | **16 máquinas de estados (FSM)** programables + **núcleo MLC** (hasta 8 flujos / 256 nodos).                             |
| Reconocimiento de eventos             | Podómetro, contador de pasos, significant motion, inclinación, free-fall, wake-up, orientación 6D/4D, clic y doble clic. |
| Sensor de temperatura                 | Termómetro interno para monitorizar la temperatura del chip.                                                             |

El magnetómetro tiene las siguientes características:

| Característica                        | Detalle                                                    |
| ------------------------------------- | ---------------------------------------------------------- |
| Rango dinámico                        | ±50 gauss (tres ejes)                                      |
| Resolución de salida                  | 16 bits                                                    |
| Consumo típico                        | 200 µA @ 20 Hz (modo alta resolución) / 50 µA (low-power)  |


## Esquema de conexión
### IMU de 6 ejes
La IMU está conectado al ESP32-S3 a través del bus I2C con la dirección 0x6A y usando estas conexiones:

| Expansor     | ESP32-S3 |
| ------------ | -------- |
| SDA          | GPIO48   |
| SCL          | GPIO47   |
| INT1         | EXP13    |
| INT2         | EXP12    |

### Magnetómetro de 3 ejes
El magnetómetro está conectado de la misma manera el bus I2C con la dirección 0x1E y usa estas conexiones:
| Expansor     | ESP32-S3 |
| ------------ | -------- |
| SDA          | GPIO48   |
| SCL          | GPIO47   |
| INT1         | EXP0     |

## Librerías recomendadas
### Arduino
- [Adafruit LSM6DS](https://github.com/adafruit/Adafruit_LSM6DS)
- [Adafruit LIS2MDL](https://github.com/adafruit/Adafruit_LIS2MDL)

### ESP-IDF
- [kode_lsm6dsox](https://components.espressif.com/components/kodediy/kode_lsm6dsox)
- [kode_lis2mdl](TBD)

## Códigos de ejemplo
### IMU de 6 ejes
```cpp LSM6DSOX_test.ino lines icon="microchip"
#include <Adafruit_LSM6DSOX.h>
#include <Wire.h>

#define I2C_SDA 48
#define I2C_SCL 47
#define I2C_FREQ 400000L

Adafruit_LSM6DSOX imu;
TwoWire I2CBus = TwoWire(0);

void setup(void) {
  Serial.begin(115200);
  while (!Serial);

  I2CBus.begin(I2C_SDA, I2C_SCL, I2C_FREQ);

  Serial.println("LSM6DSOX test");

  if (!imu.begin_I2C(0x6A, &I2CBus)) {
    Serial.println("Failed to find LSM6DSOX chip");
    while (1) {
      delay(10);
    }
  }

  Serial.println("LSM6DSOX Found!");

  // sox.setAccelRange(LSM6DS_ACCEL_RANGE_2_G);
  Serial.print("Accelerometer range set to: ");
  switch (imu.getAccelRange()) {
  case LSM6DS_ACCEL_RANGE_2_G:
    Serial.println("+-2G");
    break;
  case LSM6DS_ACCEL_RANGE_4_G:
    Serial.println("+-4G");
    break;
  case LSM6DS_ACCEL_RANGE_8_G:
    Serial.println("+-8G");
    break;
  case LSM6DS_ACCEL_RANGE_16_G:
    Serial.println("+-16G");
    break;
  }

  // sox.setGyroRange(LSM6DS_GYRO_RANGE_250_DPS );
  Serial.print("Gyro range set to: ");
  switch (imu.getGyroRange()) {
  case LSM6DS_GYRO_RANGE_125_DPS:
    Serial.println("125 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_250_DPS:
    Serial.println("250 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_500_DPS:
    Serial.println("500 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_1000_DPS:
    Serial.println("1000 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_2000_DPS:
    Serial.println("2000 degrees/s");
    break;
  case ISM330DHCX_GYRO_RANGE_4000_DPS:
    break; // unsupported range for the DSOX
  }

  // sox.setAccelDataRate(LSM6DS_RATE_12_5_HZ);
  Serial.print("Accelerometer data rate set to: ");
  switch (imu.getAccelDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }

  // sox.setGyroDataRate(LSM6DS_RATE_12_5_HZ);
  Serial.print("Gyro data rate set to: ");
  switch (imu.getGyroDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }
}

void loop() {

  //  /* Get a new normalized sensor event */
  sensors_event_t accel;
  sensors_event_t gyro;
  sensors_event_t temp;
  imu.getEvent(&accel, &gyro, &temp);

  Serial.print("\t\tTemperature ");
  Serial.print(temp.temperature);
  Serial.println(" deg C");

  /* Display the results (acceleration is measured in m/s^2) */
  Serial.print("\t\tAccel X: ");
  Serial.print(accel.acceleration.x);
  Serial.print(" \tY: ");
  Serial.print(accel.acceleration.y);
  Serial.print(" \tZ: ");
  Serial.print(accel.acceleration.z);
  Serial.println(" m/s^2 ");

  /* Display the results (rotation is measured in rad/s) */
  Serial.print("\t\tGyro X: ");
  Serial.print(gyro.gyro.x);
  Serial.print(" \tY: ");
  Serial.print(gyro.gyro.y);
  Serial.print(" \tZ: ");
  Serial.print(gyro.gyro.z);
  Serial.println(" radians/s ");
  Serial.println();

  delay(100);
}
```


### Magnetómetro de 3 ejes
```cpp LIS2MDL_test.ino lines icon="microchip"
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_LIS2MDL.h>

#define I2C_SDA 48
#define I2C_SCL 47
#define I2C_FREQ 400000L

Adafruit_LIS2MDL mag = Adafruit_LIS2MDL(12345);
TwoWire I2CBus = TwoWire(0);

void setup(void)
{
  Serial.begin(115200);
  while (!Serial);

  I2CBus.begin(I2C_SDA, I2C_SCL, I2C_FREQ);
  
  Serial.println("Magnetometer Test"); Serial.println("");

  /* Initialise the sensor */
  if(!mag.begin(0x1E, &I2CBus))
  {
    /* There was a problem detecting the LIS2MDL ... check your connections */
    Serial.println("Ooops, no LIS2MDL detected ... Check your wiring!");
    while(1);
  }
}

void loop(void)
{
  /* Get a new sensor event */
  sensors_event_t event;
  mag.getEvent(&event);

  float Pi = 3.14159;

  // Calculate the angle of the vector y,x
  float heading = (atan2(event.magnetic.y,event.magnetic.x) * 180) / Pi;

  // Normalize to 0-360
  if (heading < 0)
  {
    heading = 360 + heading;
  }
  Serial.print("Compass Heading: ");
  Serial.println(heading);
  delay(500);
}

```



## Descarga del código
Puedes probar los códigos de ejemplo mediante el IDE de Arduino o el IDE de ESP-IDF o descargar los códigos en nuestro drive:

- TBD